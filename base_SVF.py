#! /usr/bin/python

import math
import numpy as np
import sys

# Compute similarity between two intervals using supplied metric
def sim_mat(interval_a, interval_b, list, i, j, metric):
    if(i < j):
        list[i][j] = metric(interval_a, interval_b)
    else:
        list[i][j] = 0

def abs_diff(a, b):
    if(a > b):
        return a - b
    else:
        return b - a

# Dynamic Time Warping algorithm
# Reads in 2 intervals and finds "distance" between them
# Traverses through 2D matrix generated by the two vectors
# Path of least resistance gives the resulting distance
def DTW(interval_a, interval_b):

    #return interval_a[0] - interval_b[0]
    
    dtw = np.zeros((len(interval_a), len(interval_b)))

    for i in range(len(interval_a)):
        dtw[i][0] = sys.maxsize
    for i in range(len(interval_b)):
        dtw[0][i] = sys.maxsize

    dtw[0][0] = 0

    for i in range(1, len(interval_a)):
        for j in range(1, len(interval_b)):
            cost = abs(interval_a[i] - interval_b[j])
            dtw[i][j] = cost + min([dtw[i-1][j], dtw[i][j-1], dtw[i-1][j-1]])

    return dtw[len(interval_a) - 1][len(interval_b) - 1]

# Compute SVF by calculating the pearson correlation between victim and attacker similarities
def SVF(v_sim, a_sim):
    v_mean = np.mean(v_sim)
    a_mean = np.mean(a_sim)
    v_std = np.std(v_sim, ddof=1)
    a_std = np.std(a_sim, ddof=1)



    sum = 0
    for i in range(min(len(v_sim), len(a_sim))):
        for j in range(min(len(v_sim[i]), len(a_sim[i]))):
            sum += (v_sim[i][j] * a_sim[i][j])

    sum -= (len(a_sim) * len(v_sim) * v_mean * a_mean)
    sum /= ((len(a_sim) * len(v_sim) - 1) * v_std * a_std)

    print len(a_sim)
    print v_mean
    print a_mean
    print v_std
    print a_std

    return sum

def main():
    v_trace = []
    a_trace = []
    
    v_file = "mem_trace.out"
    a_file = "dcache_trace.out"

    # Read in victim trace
    # Trace is formated so that 1 line contains 1 "interval", aka 1 attacker read
    with open(v_file) as f:
        for line in f:
            next = line.strip().split(" ")
            temp = []
            for item in next:
                temp.append(int(item))

            temp = filter(None, temp)
            v_trace.append(temp)

    # Read in what attacker sees
    # Trace is formated so that 1 line = 1 piece of information, which corresponds to 1 victim interval
    with open(a_file) as f:
        for next in f:
            a_trace.append(int(next))

    v_sim = np.zeros((len(v_trace), len(v_trace)))
    a_sim = np.zeros((len(a_trace), len(a_trace)))

    print "Generating victim similarity matrix"

    # Generate similarity matrix by comparing similarities between intervals
    for i in range(0, len(v_trace)):
        for j in range(0, len(v_trace)):
            sim_mat(v_trace[i], v_trace[j], v_sim, i, j, DTW)

    print "Generating attacker similarity matrix"

    for i in range(0, len(a_trace)):
        for j in range(0, len(a_trace)):
            sim_mat(a_trace[i], a_trace[j], a_sim, i, j, abs_diff)

    print v_sim
    print a_sim

    print "Computing SVF"
    ret = SVF(v_sim, a_sim)
    print ret

main()
